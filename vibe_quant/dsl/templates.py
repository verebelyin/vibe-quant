"""Static code templates for the DSL-to-NautilusTrader compiler.

Contains generated method bodies that are the same for every compiled strategy.
Dynamic/indicator-dependent generation stays in :mod:`compiler`.
"""

from __future__ import annotations

# ---------------------------------------------------------------------------
# Event handling (static â€“ no DSL-dependent logic)
# ---------------------------------------------------------------------------

ON_EVENT_LINES: tuple[str, ...] = (
    "def on_event(self, event) -> None:",
    '    """Handle strategy events for position tracking and SL/TP submission."""',
    "    if isinstance(event, PositionOpened):",
    "        if event.instrument_id == self.instrument_id:",
    "            self._sync_position_state()",
    "            # Submit SL/TP using actual fill price from opened position",
    "            pos = self.cache.position(event.position_id)",
    "            if pos is not None:",
    "                entry_price = float(pos.avg_px_open)",
    "                entry_side = OrderSide.BUY if pos.entry == PositionSide.LONG else OrderSide.SELL",
    "                self._submit_sl_tp_orders(entry_price, entry_side, pos.quantity)",
    "    elif isinstance(event, PositionClosed):",
    "        if event.instrument_id == self.instrument_id:",
    "            self._position_open = False",
    "            self._position_side = None",
    "            self.cancel_all_orders(self.instrument_id)",
    "    elif isinstance(event, OrderFilled):",
    "        if event.instrument_id == self.instrument_id:",
    "            self._sync_position_state()",
)

ON_STOP_LINES: tuple[str, ...] = (
    "def on_stop(self) -> None:",
    '    """Strategy shutdown: cancel orders and close positions."""',
    "    self.cancel_all_orders(self.instrument_id)",
    "    self.close_all_positions(self.instrument_id)",
)

# ---------------------------------------------------------------------------
# Order submission and position management (static)
# ---------------------------------------------------------------------------

ORDER_METHODS_LINES: tuple[str, ...] = (
    # _submit_long_entry
    "def _submit_long_entry(self, bar: Bar) -> None:",
    '    """Submit a long entry order with SL/TP."""',
    "    if self._position_open:",
    "        return",
    "",
    "    qty = self._calculate_position_size(bar, is_long=True)",
    "    order = self.order_factory.market(",
    "        instrument_id=self.instrument_id,",
    "        order_side=OrderSide.BUY,",
    "        quantity=qty,",
    "        time_in_force=TimeInForce.IOC,",
    "    )",
    "    self.submit_order(order)",
    "    # SL/TP orders are submitted from on_event(PositionOpened) after fill",
    "",
    # _submit_short_entry
    "def _submit_short_entry(self, bar: Bar) -> None:",
    '    """Submit a short entry order with SL/TP."""',
    "    if self._position_open:",
    "        return",
    "",
    "    qty = self._calculate_position_size(bar, is_long=False)",
    "    order = self.order_factory.market(",
    "        instrument_id=self.instrument_id,",
    "        order_side=OrderSide.SELL,",
    "        quantity=qty,",
    "        time_in_force=TimeInForce.IOC,",
    "    )",
    "    self.submit_order(order)",
    "    # SL/TP orders are submitted from on_event(PositionOpened) after fill",
    "",
    # _submit_exit
    "def _submit_exit(self, bar: Bar) -> None:",
    '    """Submit an exit order using actual position quantity from cache."""',
    "    if not self._position_open:",
    "        return",
    "",
    "    # Cancel existing SL/TP orders",
    "    self.cancel_all_orders(self.instrument_id)",
    "",
    "    # Determine exit side and get actual position quantity from cache",
    "    exit_side = OrderSide.SELL if self._position_side == OrderSide.BUY else OrderSide.BUY",
    "    quantity = self._calculate_position_size(bar)",
    "    positions = self.cache.positions_open(venue=self.instrument_id.venue)",
    "    for pos in positions:",
    "        if pos.instrument_id == self.instrument_id and pos.is_open:",
    "            quantity = pos.quantity",
    "            break",
    "",
    "    order = self.order_factory.market(",
    "        instrument_id=self.instrument_id,",
    "        order_side=exit_side,",
    "        quantity=quantity,",
    "        time_in_force=TimeInForce.IOC,",
    "    )",
    "    self.submit_order(order)",
    "",
    # _submit_sl_tp_orders
    "def _submit_sl_tp_orders(self, entry_price: float, side: OrderSide, qty: Quantity) -> None:",
    '    """Submit stop-loss and take-profit orders after entry."""',
    "    is_long = side == OrderSide.BUY",
    "",
    "    # Calculate and submit stop-loss order",
    "    sl_price = self._calculate_sl_price(entry_price, is_long)",
    "    if sl_price is not None:",
    "        sl_side = OrderSide.SELL if is_long else OrderSide.BUY",
    "        sl_order = self.order_factory.stop_market(",
    "            instrument_id=self.instrument_id,",
    "            order_side=sl_side,",
    "            quantity=qty,",
    "            trigger_price=self.instrument.make_price(sl_price),",
    "            time_in_force=TimeInForce.GTC,",
    "            reduce_only=True,",
    "        )",
    "        self.submit_order(sl_order)",
    "",
    "    # Calculate and submit take-profit order",
    "    tp_price = self._calculate_tp_price(entry_price, is_long)",
    "    if tp_price is not None:",
    "        tp_side = OrderSide.SELL if is_long else OrderSide.BUY",
    "        tp_order = self.order_factory.limit(",
    "            instrument_id=self.instrument_id,",
    "            order_side=tp_side,",
    "            quantity=qty,",
    "            price=self.instrument.make_price(tp_price),",
    "            time_in_force=TimeInForce.GTC,",
    "            reduce_only=True,",
    "        )",
    "        self.submit_order(tp_order)",
    "",
    # _calculate_sl_price
    "def _calculate_sl_price(self, entry_price: float, is_long: bool) -> float | None:",
    '    """Calculate stop-loss price based on config type."""',
    "    sl_type = self.config.stop_loss_type",
    '    if sl_type == "fixed_pct":',
    "        pct = self.config.stop_loss_percent",
    "        if is_long:",
    "            return entry_price * (1 - pct / 100)",
    "        else:",
    "            return entry_price * (1 + pct / 100)",
    '    elif sl_type in ("atr_fixed", "atr_trailing"):',
    "        sl_ind = getattr(self.config, 'stop_loss_indicator', None)",
    "        if sl_ind is None:",
    "            return None",
    "        atr_value = self._get_indicator_value(sl_ind)",
    "        multiplier = self.config.stop_loss_atr_multiplier",
    "        if is_long:",
    "            return entry_price - atr_value * multiplier",
    "        else:",
    "            return entry_price + atr_value * multiplier",
    "    return None",
    "",
    # _update_trailing_stop -- called from on_bar when atr_trailing
    "def _update_trailing_stop(self, bar: Bar) -> None:",
    '    """Update trailing stop loss as price moves favorably."""',
    '    if not self._position_open or self.config.stop_loss_type != "atr_trailing":',
    "        return",
    "    sl_ind = getattr(self.config, 'stop_loss_indicator', None)",
    "    if sl_ind is None:",
    "        return",
    "    atr_value = self._get_indicator_value(sl_ind)",
    "    multiplier = self.config.stop_loss_atr_multiplier",
    "    is_long = self._position_side == OrderSide.BUY",
    "    current_price = float(bar.close.as_double())",
    "    if is_long:",
    "        new_sl = current_price - atr_value * multiplier",
    "        best = getattr(self, '_trailing_best_sl', None)",
    "        if best is None or new_sl > best:",
    "            self._trailing_best_sl = new_sl",
    "        else:",
    "            return  # SL hasn't improved",
    "    else:",
    "        new_sl = current_price + atr_value * multiplier",
    "        best = getattr(self, '_trailing_best_sl', None)",
    "        if best is None or new_sl < best:",
    "            self._trailing_best_sl = new_sl",
    "        else:",
    "            return  # SL hasn't improved",
    "    # Cancel existing SL orders and resubmit at new price",
    "    for order in self.cache.orders_open(venue=self.instrument_id.venue):",
    "        if (order.instrument_id == self.instrument_id",
    "                and order.is_reduce_only and hasattr(order, 'trigger_price')):",
    "            self.cancel_order(order)",
    "    positions = self.cache.positions_open(venue=self.instrument_id.venue)",
    "    for pos in positions:",
    "        if pos.instrument_id == self.instrument_id and pos.is_open:",
    "            sl_side = OrderSide.SELL if is_long else OrderSide.BUY",
    "            sl_order = self.order_factory.stop_market(",
    "                instrument_id=self.instrument_id,",
    "                order_side=sl_side,",
    "                quantity=pos.quantity,",
    "                trigger_price=self.instrument.make_price(self._trailing_best_sl),",
    "                time_in_force=TimeInForce.GTC,",
    "                reduce_only=True,",
    "            )",
    "            self.submit_order(sl_order)",
    "            break",
    "",
    # _calculate_tp_price
    "def _calculate_tp_price(self, entry_price: float, is_long: bool) -> float | None:",
    '    """Calculate take-profit price based on config type."""',
    "    tp_type = self.config.take_profit_type",
    '    if tp_type == "fixed_pct":',
    "        pct = self.config.take_profit_percent",
    "        if is_long:",
    "            return entry_price * (1 + pct / 100)",
    "        else:",
    "            return entry_price * (1 - pct / 100)",
    '    elif tp_type == "atr_fixed":',
    "        tp_ind = getattr(self.config, 'take_profit_indicator', None)",
    "        if tp_ind is None:",
    "            return None",
    "        atr_value = self._get_indicator_value(tp_ind)",
    "        multiplier = self.config.take_profit_atr_multiplier",
    "        if is_long:",
    "            return entry_price + atr_value * multiplier",
    "        else:",
    "            return entry_price - atr_value * multiplier",
    '    elif tp_type == "risk_reward":',
    "        sl_price = self._calculate_sl_price(entry_price, is_long)",
    "        if sl_price is not None:",
    "            sl_distance = abs(entry_price - sl_price)",
    "            ratio = self.config.take_profit_risk_reward",
    "            if is_long:",
    "                return entry_price + sl_distance * ratio",
    "            else:",
    "                return entry_price - sl_distance * ratio",
    "    return None",
    "",
    # _calculate_position_size
    "def _calculate_position_size(self, bar: Bar, is_long: bool = True) -> Quantity:",
    '    """Calculate position size based on risk config."""',
    "    # Get account equity from cache",
    "    account = self.cache.account_for_venue(self.instrument_id.venue)",
    "    if account is None:",
    "        return self.instrument.make_qty(1.0)",
    "",
    "    equity = float(account.balance_total(account.currencies()[0]))",
    "    if equity <= 0:",
    "        return self.instrument.make_qty(1.0)",
    "",
    "    price = float(bar.close)",
    "    if price <= 0:",
    "        return self.instrument.make_qty(1.0)",
    "",
    "    # Fixed fractional sizing: risk_per_trade % of equity",
    "    risk_pct = getattr(self.config, 'risk_per_trade', 0.02)",
    "    risk_amount = equity * risk_pct",
    "",
    "    # Use stop loss distance if available, otherwise use 2% of price",
    "    sl_price = self._calculate_sl_price(price, is_long)",
    "    if sl_price is not None and sl_price > 0:",
    "        stop_distance = abs(price - sl_price)",
    "    else:",
    "        stop_distance = price * 0.02  # 2% default stop distance",
    "",
    "    if stop_distance <= 0:",
    "        stop_distance = price * 0.02",
    "",
    "    # Size = risk_amount / stop_distance",
    "    raw_size = risk_amount / stop_distance",
    "",
    "    # Apply max position limit (configurable, default 50% of equity)",
    "    max_pos_pct = getattr(self.config, 'max_position_pct', 0.5)",
    "    max_size = (equity * max_pos_pct) / price",
    "    final_size = min(raw_size, max_size)",
    "",
    "    # Ensure minimum quantity: 1% of equity at current price",
    "    min_size = (equity * 0.01) / price if price > 0 else 0.001",
    "    if final_size <= 0:",
    "        final_size = min_size",
    "",
    "    # Clamp to instrument minimums",
    "    if self.instrument.min_quantity is not None:",
    "        final_size = max(final_size, float(self.instrument.min_quantity))",
    "    return self.instrument.make_qty(final_size)",
    "",
    # _sync_position_state
    "def _sync_position_state(self) -> None:",
    '    """Sync position tracking state from cache."""',
    "    positions = self.cache.positions_open(venue=self.instrument_id.venue)",
    "    for pos in positions:",
    "        if pos.instrument_id == self.instrument_id and pos.is_open:",
    "            self._position_open = True",
    "            self._position_side = OrderSide.BUY if pos.entry == PositionSide.LONG else OrderSide.SELL",
    "            return",
    "    self._position_open = False",
    "    self._position_side = None",
)
