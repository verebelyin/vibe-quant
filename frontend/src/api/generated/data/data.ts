/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * vibe-quant API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BrowseDataApiDataBrowseSymbolGetParams,
  BrowseDataResponse,
  DataCoverageResponse,
  DataQualityResponse,
  DataStatusResponse,
  DownloadHistoryApiDataHistoryGet200Item,
  DownloadHistoryApiDataHistoryGetParams,
  HTTPValidationError,
  IngestPreviewResponse,
  IngestRequest,
  RebuildCatalogApiDataRebuildPost202,
  StartIngestApiDataIngestPost202,
  StartUpdateApiDataUpdatePost202
} from '.././models';

import { customInstance } from '../../client';




/**
 * @summary Data Status
 */
export type dataStatusApiDataStatusGetResponse200 = {
  data: DataStatusResponse
  status: 200
}

export type dataStatusApiDataStatusGetResponseSuccess = (dataStatusApiDataStatusGetResponse200) & {
  headers: Headers;
};
;

export type dataStatusApiDataStatusGetResponse = (dataStatusApiDataStatusGetResponseSuccess)

export const getDataStatusApiDataStatusGetUrl = () => {


  

  return `/api/data/status`
}

export const dataStatusApiDataStatusGet = async ( options?: RequestInit): Promise<dataStatusApiDataStatusGetResponse> => {
  
  return customInstance<dataStatusApiDataStatusGetResponse>(getDataStatusApiDataStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDataStatusApiDataStatusGetQueryKey = () => {
    return [
    `/api/data/status`
    ] as const;
    }

    
export const getDataStatusApiDataStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDataStatusApiDataStatusGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>> = ({ signal }) => dataStatusApiDataStatusGet({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DataStatusApiDataStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>>
export type DataStatusApiDataStatusGetQueryError = unknown


export function useDataStatusApiDataStatusGet<TData = Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>,
          TError,
          Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataStatusApiDataStatusGet<TData = Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>,
          TError,
          Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataStatusApiDataStatusGet<TData = Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Data Status
 */

export function useDataStatusApiDataStatusGet<TData = Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataStatusApiDataStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDataStatusApiDataStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Data Coverage
 */
export type dataCoverageApiDataCoverageGetResponse200 = {
  data: DataCoverageResponse
  status: 200
}

export type dataCoverageApiDataCoverageGetResponseSuccess = (dataCoverageApiDataCoverageGetResponse200) & {
  headers: Headers;
};
;

export type dataCoverageApiDataCoverageGetResponse = (dataCoverageApiDataCoverageGetResponseSuccess)

export const getDataCoverageApiDataCoverageGetUrl = () => {


  

  return `/api/data/coverage`
}

export const dataCoverageApiDataCoverageGet = async ( options?: RequestInit): Promise<dataCoverageApiDataCoverageGetResponse> => {
  
  return customInstance<dataCoverageApiDataCoverageGetResponse>(getDataCoverageApiDataCoverageGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDataCoverageApiDataCoverageGetQueryKey = () => {
    return [
    `/api/data/coverage`
    ] as const;
    }

    
export const getDataCoverageApiDataCoverageGetQueryOptions = <TData = Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDataCoverageApiDataCoverageGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>> = ({ signal }) => dataCoverageApiDataCoverageGet({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DataCoverageApiDataCoverageGetQueryResult = NonNullable<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>>
export type DataCoverageApiDataCoverageGetQueryError = unknown


export function useDataCoverageApiDataCoverageGet<TData = Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>,
          TError,
          Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataCoverageApiDataCoverageGet<TData = Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>,
          TError,
          Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataCoverageApiDataCoverageGet<TData = Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Data Coverage
 */

export function useDataCoverageApiDataCoverageGet<TData = Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataCoverageApiDataCoverageGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDataCoverageApiDataCoverageGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary List Symbols
 */
export type listSymbolsApiDataSymbolsGetResponse200 = {
  data: string[]
  status: 200
}

export type listSymbolsApiDataSymbolsGetResponseSuccess = (listSymbolsApiDataSymbolsGetResponse200) & {
  headers: Headers;
};
;

export type listSymbolsApiDataSymbolsGetResponse = (listSymbolsApiDataSymbolsGetResponseSuccess)

export const getListSymbolsApiDataSymbolsGetUrl = () => {


  

  return `/api/data/symbols`
}

export const listSymbolsApiDataSymbolsGet = async ( options?: RequestInit): Promise<listSymbolsApiDataSymbolsGetResponse> => {
  
  return customInstance<listSymbolsApiDataSymbolsGetResponse>(getListSymbolsApiDataSymbolsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListSymbolsApiDataSymbolsGetQueryKey = () => {
    return [
    `/api/data/symbols`
    ] as const;
    }

    
export const getListSymbolsApiDataSymbolsGetQueryOptions = <TData = Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSymbolsApiDataSymbolsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>> = ({ signal }) => listSymbolsApiDataSymbolsGet({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSymbolsApiDataSymbolsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>>
export type ListSymbolsApiDataSymbolsGetQueryError = unknown


export function useListSymbolsApiDataSymbolsGet<TData = Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>,
          TError,
          Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSymbolsApiDataSymbolsGet<TData = Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>,
          TError,
          Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSymbolsApiDataSymbolsGet<TData = Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Symbols
 */

export function useListSymbolsApiDataSymbolsGet<TData = Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSymbolsApiDataSymbolsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSymbolsApiDataSymbolsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Ingest Preview
 */
export type ingestPreviewApiDataIngestPreviewPostResponse200 = {
  data: IngestPreviewResponse
  status: 200
}

export type ingestPreviewApiDataIngestPreviewPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type ingestPreviewApiDataIngestPreviewPostResponseSuccess = (ingestPreviewApiDataIngestPreviewPostResponse200) & {
  headers: Headers;
};
export type ingestPreviewApiDataIngestPreviewPostResponseError = (ingestPreviewApiDataIngestPreviewPostResponse422) & {
  headers: Headers;
};

export type ingestPreviewApiDataIngestPreviewPostResponse = (ingestPreviewApiDataIngestPreviewPostResponseSuccess | ingestPreviewApiDataIngestPreviewPostResponseError)

export const getIngestPreviewApiDataIngestPreviewPostUrl = () => {


  

  return `/api/data/ingest/preview`
}

export const ingestPreviewApiDataIngestPreviewPost = async (ingestRequest: IngestRequest, options?: RequestInit): Promise<ingestPreviewApiDataIngestPreviewPostResponse> => {
  
  return customInstance<ingestPreviewApiDataIngestPreviewPostResponse>(getIngestPreviewApiDataIngestPreviewPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestRequest,)
  }
);}




export const getIngestPreviewApiDataIngestPreviewPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>, TError,{data: IngestRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>, TError,{data: IngestRequest}, TContext> => {

const mutationKey = ['ingestPreviewApiDataIngestPreviewPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>, {data: IngestRequest}> = (props) => {
          const {data} = props ?? {};

          return  ingestPreviewApiDataIngestPreviewPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IngestPreviewApiDataIngestPreviewPostMutationResult = NonNullable<Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>>
    export type IngestPreviewApiDataIngestPreviewPostMutationBody = IngestRequest
    export type IngestPreviewApiDataIngestPreviewPostMutationError = HTTPValidationError

    /**
 * @summary Ingest Preview
 */
export const useIngestPreviewApiDataIngestPreviewPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>, TError,{data: IngestRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingestPreviewApiDataIngestPreviewPost>>,
        TError,
        {data: IngestRequest},
        TContext
      > => {
      return useMutation(getIngestPreviewApiDataIngestPreviewPostMutationOptions(options), queryClient);
    }
    /**
 * @summary Start Ingest
 */
export type startIngestApiDataIngestPostResponse202 = {
  data: StartIngestApiDataIngestPost202
  status: 202
}

export type startIngestApiDataIngestPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type startIngestApiDataIngestPostResponseSuccess = (startIngestApiDataIngestPostResponse202) & {
  headers: Headers;
};
export type startIngestApiDataIngestPostResponseError = (startIngestApiDataIngestPostResponse422) & {
  headers: Headers;
};

export type startIngestApiDataIngestPostResponse = (startIngestApiDataIngestPostResponseSuccess | startIngestApiDataIngestPostResponseError)

export const getStartIngestApiDataIngestPostUrl = () => {


  

  return `/api/data/ingest`
}

export const startIngestApiDataIngestPost = async (ingestRequest: IngestRequest, options?: RequestInit): Promise<startIngestApiDataIngestPostResponse> => {
  
  return customInstance<startIngestApiDataIngestPostResponse>(getStartIngestApiDataIngestPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestRequest,)
  }
);}




export const getStartIngestApiDataIngestPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startIngestApiDataIngestPost>>, TError,{data: IngestRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startIngestApiDataIngestPost>>, TError,{data: IngestRequest}, TContext> => {

const mutationKey = ['startIngestApiDataIngestPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startIngestApiDataIngestPost>>, {data: IngestRequest}> = (props) => {
          const {data} = props ?? {};

          return  startIngestApiDataIngestPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StartIngestApiDataIngestPostMutationResult = NonNullable<Awaited<ReturnType<typeof startIngestApiDataIngestPost>>>
    export type StartIngestApiDataIngestPostMutationBody = IngestRequest
    export type StartIngestApiDataIngestPostMutationError = HTTPValidationError

    /**
 * @summary Start Ingest
 */
export const useStartIngestApiDataIngestPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startIngestApiDataIngestPost>>, TError,{data: IngestRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startIngestApiDataIngestPost>>,
        TError,
        {data: IngestRequest},
        TContext
      > => {
      return useMutation(getStartIngestApiDataIngestPostMutationOptions(options), queryClient);
    }
    /**
 * @summary Start Update
 */
export type startUpdateApiDataUpdatePostResponse202 = {
  data: StartUpdateApiDataUpdatePost202
  status: 202
}

export type startUpdateApiDataUpdatePostResponseSuccess = (startUpdateApiDataUpdatePostResponse202) & {
  headers: Headers;
};
;

export type startUpdateApiDataUpdatePostResponse = (startUpdateApiDataUpdatePostResponseSuccess)

export const getStartUpdateApiDataUpdatePostUrl = () => {


  

  return `/api/data/update`
}

export const startUpdateApiDataUpdatePost = async ( options?: RequestInit): Promise<startUpdateApiDataUpdatePostResponse> => {
  
  return customInstance<startUpdateApiDataUpdatePostResponse>(getStartUpdateApiDataUpdatePostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getStartUpdateApiDataUpdatePostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>, TError,void, TContext> => {

const mutationKey = ['startUpdateApiDataUpdatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>, void> = () => {
          

          return  startUpdateApiDataUpdatePost()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StartUpdateApiDataUpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>>
    
    export type StartUpdateApiDataUpdatePostMutationError = unknown

    /**
 * @summary Start Update
 */
export const useStartUpdateApiDataUpdatePost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startUpdateApiDataUpdatePost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getStartUpdateApiDataUpdatePostMutationOptions(options), queryClient);
    }
    /**
 * @summary Rebuild Catalog
 */
export type rebuildCatalogApiDataRebuildPostResponse202 = {
  data: RebuildCatalogApiDataRebuildPost202
  status: 202
}

export type rebuildCatalogApiDataRebuildPostResponseSuccess = (rebuildCatalogApiDataRebuildPostResponse202) & {
  headers: Headers;
};
;

export type rebuildCatalogApiDataRebuildPostResponse = (rebuildCatalogApiDataRebuildPostResponseSuccess)

export const getRebuildCatalogApiDataRebuildPostUrl = () => {


  

  return `/api/data/rebuild`
}

export const rebuildCatalogApiDataRebuildPost = async ( options?: RequestInit): Promise<rebuildCatalogApiDataRebuildPostResponse> => {
  
  return customInstance<rebuildCatalogApiDataRebuildPostResponse>(getRebuildCatalogApiDataRebuildPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRebuildCatalogApiDataRebuildPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>, TError,void, TContext> => {

const mutationKey = ['rebuildCatalogApiDataRebuildPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>, void> = () => {
          

          return  rebuildCatalogApiDataRebuildPost()
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RebuildCatalogApiDataRebuildPostMutationResult = NonNullable<Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>>
    
    export type RebuildCatalogApiDataRebuildPostMutationError = unknown

    /**
 * @summary Rebuild Catalog
 */
export const useRebuildCatalogApiDataRebuildPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rebuildCatalogApiDataRebuildPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getRebuildCatalogApiDataRebuildPostMutationOptions(options), queryClient);
    }
    /**
 * @summary Browse Data
 */
export type browseDataApiDataBrowseSymbolGetResponse200 = {
  data: BrowseDataResponse
  status: 200
}

export type browseDataApiDataBrowseSymbolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type browseDataApiDataBrowseSymbolGetResponseSuccess = (browseDataApiDataBrowseSymbolGetResponse200) & {
  headers: Headers;
};
export type browseDataApiDataBrowseSymbolGetResponseError = (browseDataApiDataBrowseSymbolGetResponse422) & {
  headers: Headers;
};

export type browseDataApiDataBrowseSymbolGetResponse = (browseDataApiDataBrowseSymbolGetResponseSuccess | browseDataApiDataBrowseSymbolGetResponseError)

export const getBrowseDataApiDataBrowseSymbolGetUrl = (symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/data/browse/${symbol}?${stringifiedParams}` : `/api/data/browse/${symbol}`
}

export const browseDataApiDataBrowseSymbolGet = async (symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams, options?: RequestInit): Promise<browseDataApiDataBrowseSymbolGetResponse> => {
  
  return customInstance<browseDataApiDataBrowseSymbolGetResponse>(getBrowseDataApiDataBrowseSymbolGetUrl(symbol,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBrowseDataApiDataBrowseSymbolGetQueryKey = (symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams,) => {
    return [
    `/api/data/browse/${symbol}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getBrowseDataApiDataBrowseSymbolGetQueryOptions = <TData = Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError = HTTPValidationError>(symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBrowseDataApiDataBrowseSymbolGetQueryKey(symbol,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>> = ({ signal }) => browseDataApiDataBrowseSymbolGet(symbol,params, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(symbol), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BrowseDataApiDataBrowseSymbolGetQueryResult = NonNullable<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>>
export type BrowseDataApiDataBrowseSymbolGetQueryError = HTTPValidationError


export function useBrowseDataApiDataBrowseSymbolGet<TData = Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError = HTTPValidationError>(
 symbol: string,
    params: undefined |  BrowseDataApiDataBrowseSymbolGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>,
          TError,
          Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBrowseDataApiDataBrowseSymbolGet<TData = Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError = HTTPValidationError>(
 symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>,
          TError,
          Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBrowseDataApiDataBrowseSymbolGet<TData = Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError = HTTPValidationError>(
 symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Browse Data
 */

export function useBrowseDataApiDataBrowseSymbolGet<TData = Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError = HTTPValidationError>(
 symbol: string,
    params?: BrowseDataApiDataBrowseSymbolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof browseDataApiDataBrowseSymbolGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBrowseDataApiDataBrowseSymbolGetQueryOptions(symbol,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Data Quality
 */
export type dataQualityApiDataQualitySymbolGetResponse200 = {
  data: DataQualityResponse
  status: 200
}

export type dataQualityApiDataQualitySymbolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type dataQualityApiDataQualitySymbolGetResponseSuccess = (dataQualityApiDataQualitySymbolGetResponse200) & {
  headers: Headers;
};
export type dataQualityApiDataQualitySymbolGetResponseError = (dataQualityApiDataQualitySymbolGetResponse422) & {
  headers: Headers;
};

export type dataQualityApiDataQualitySymbolGetResponse = (dataQualityApiDataQualitySymbolGetResponseSuccess | dataQualityApiDataQualitySymbolGetResponseError)

export const getDataQualityApiDataQualitySymbolGetUrl = (symbol: string,) => {


  

  return `/api/data/quality/${symbol}`
}

export const dataQualityApiDataQualitySymbolGet = async (symbol: string, options?: RequestInit): Promise<dataQualityApiDataQualitySymbolGetResponse> => {
  
  return customInstance<dataQualityApiDataQualitySymbolGetResponse>(getDataQualityApiDataQualitySymbolGetUrl(symbol),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDataQualityApiDataQualitySymbolGetQueryKey = (symbol: string,) => {
    return [
    `/api/data/quality/${symbol}`
    ] as const;
    }

    
export const getDataQualityApiDataQualitySymbolGetQueryOptions = <TData = Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError = HTTPValidationError>(symbol: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDataQualityApiDataQualitySymbolGetQueryKey(symbol);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>> = ({ signal }) => dataQualityApiDataQualitySymbolGet(symbol, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(symbol), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DataQualityApiDataQualitySymbolGetQueryResult = NonNullable<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>>
export type DataQualityApiDataQualitySymbolGetQueryError = HTTPValidationError


export function useDataQualityApiDataQualitySymbolGet<TData = Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError = HTTPValidationError>(
 symbol: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>,
          TError,
          Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataQualityApiDataQualitySymbolGet<TData = Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError = HTTPValidationError>(
 symbol: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>,
          TError,
          Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataQualityApiDataQualitySymbolGet<TData = Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError = HTTPValidationError>(
 symbol: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Data Quality
 */

export function useDataQualityApiDataQualitySymbolGet<TData = Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError = HTTPValidationError>(
 symbol: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataQualityApiDataQualitySymbolGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDataQualityApiDataQualitySymbolGetQueryOptions(symbol,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Download History
 */
export type downloadHistoryApiDataHistoryGetResponse200 = {
  data: DownloadHistoryApiDataHistoryGet200Item[]
  status: 200
}

export type downloadHistoryApiDataHistoryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type downloadHistoryApiDataHistoryGetResponseSuccess = (downloadHistoryApiDataHistoryGetResponse200) & {
  headers: Headers;
};
export type downloadHistoryApiDataHistoryGetResponseError = (downloadHistoryApiDataHistoryGetResponse422) & {
  headers: Headers;
};

export type downloadHistoryApiDataHistoryGetResponse = (downloadHistoryApiDataHistoryGetResponseSuccess | downloadHistoryApiDataHistoryGetResponseError)

export const getDownloadHistoryApiDataHistoryGetUrl = (params?: DownloadHistoryApiDataHistoryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/data/history?${stringifiedParams}` : `/api/data/history`
}

export const downloadHistoryApiDataHistoryGet = async (params?: DownloadHistoryApiDataHistoryGetParams, options?: RequestInit): Promise<downloadHistoryApiDataHistoryGetResponse> => {
  
  return customInstance<downloadHistoryApiDataHistoryGetResponse>(getDownloadHistoryApiDataHistoryGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDownloadHistoryApiDataHistoryGetQueryKey = (params?: DownloadHistoryApiDataHistoryGetParams,) => {
    return [
    `/api/data/history`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getDownloadHistoryApiDataHistoryGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError = HTTPValidationError>(params?: DownloadHistoryApiDataHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadHistoryApiDataHistoryGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>> = ({ signal }) => downloadHistoryApiDataHistoryGet(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadHistoryApiDataHistoryGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>>
export type DownloadHistoryApiDataHistoryGetQueryError = HTTPValidationError


export function useDownloadHistoryApiDataHistoryGet<TData = Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError = HTTPValidationError>(
 params: undefined |  DownloadHistoryApiDataHistoryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadHistoryApiDataHistoryGet<TData = Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError = HTTPValidationError>(
 params?: DownloadHistoryApiDataHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadHistoryApiDataHistoryGet<TData = Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError = HTTPValidationError>(
 params?: DownloadHistoryApiDataHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download History
 */

export function useDownloadHistoryApiDataHistoryGet<TData = Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError = HTTPValidationError>(
 params?: DownloadHistoryApiDataHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadHistoryApiDataHistoryGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadHistoryApiDataHistoryGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




